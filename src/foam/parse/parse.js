/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Interface for parsers. Mostly exists for type-checking.
 */
foam.INTERFACE({
  package: 'foam.parse',
  name: 'Parser',
  methods: [
    {
      /**
       * Main parsing function: attempts to consume input and produce a
       * parsed result.
       *
       * Returns <tt>undefined</tt> to signal parsing failure, or a
       * <tt>PStream</tt>, maybe with its <tt>value</tt> set, on success.
       *
       * For method argument typing, use {Parse} as your type to accept
       * both foam.parse.Parser and other types that can be coerced to a
       * parser (such as strings to Literals).
       */
      name: 'parse',
      args: [
        {
          /** The <tt>PStream</tt> representing the input string. */
          name: 'ps',
          typeName: 'foam.parse.PStream'
        },
        {
          /**
           * The map of names to parsers that define the user's grammar.
           *
           * Passed down through all the parsers, but only used by
           * <tt>Symbol</tt> to resolve parser names.
           */
          name: 'grammar',
          typeName: 'foam.parse.Grammar'
        }
      ]
    }
  ]
});


/**
 * A <tt>PStream</tt> is the interface for the input stream consumed by the
 * <tt>Parser</tt>s.
 *
 * <tt>PStreams</tt> have the following interface:
 * <table>
 * <tr>
 *   <td><tt>int</tt></td>
 *   <td><tt>pos</tt></td>
 *   <td>The character position in the input stream.</td>
 * </tr>
 * <tr>
 *   <td><tt>char</tt></td>
 *   <td><tt>head</tt></td>
 *   <td>The first character in the stream.</td>
 * </tr>
 * <tr>
 *   <td><tt>PStream</tt></td>
 *   <td><tt>tail</tt></td>
 *   <td>A <tt>PStream</tt> for the remainder of the input steam.</td>
 * </tr>
 * <tr>
 *   <td><tt>Any</tt></td>
 *   <td><tt>value</tt></td>
 *   <td>The 'value' associated with this <tt>PStream</tt>.
 *     Eg. a parsed number.</td>
 * </tr>
 * <tr>
 *   <td><tt>PStream</tt></td>
 *   <td><tt>setValue(Object value)</tt></td>
 *   <td>Create a new <tt>PStream</tt> at the same position
 *       but with a new 'value'. The value is used to hold the result of a
 *       (sub-)parse.</td>
 * </tr>
 * </table>
 *
 * <tt>PStreams</tt> are immutable, which greatly simplifies backtracking.
 */
foam.INTERFACE({
  package: 'foam.parse',
  name: 'PStream',
  properties: [
    // No types are given here, so that they can be Unsafe properties.
    {
      /** Index into the input stream. */
      class: 'Unsafe',
      name: 'pos'
    },
    {
      /** The input string, wrapped in an array to simulate a pointer. */
      class: 'Unsafe',
      name: 'str'
    },
    {
      /** The output value from the parser. */
      name: 'value'
    }
  ],

  methods: [
    {
      /**
       * Creates a new PStream at the same position but with a new
       * <tt>value</tt> set. This value holds the result of parsing.
       */
      name: 'setValue',
      returnType: 'foam.parse.PStream',
      args: [
        {
          /** The new value. */
          name: 'value',
          typeName: 'any'
        }
      ]
    }
  ]
});


// FUTURE(adamvy): Detect non string values passed to StringPS.setString()

/**
  Parser combinator library.

  Create complex parsers by composing simple parsers.

  A <tt>PStream</tt> is a "Parser Stream", the input format accepted by
  FOAM parsers.

  A parser has the following interface:

  <pre>
    PStream parse(PStream stream);
  </pre>

  It takes as input a <tt>PStream</tt>, and returns either a <tt>PStream</tt>
  advanced to the point after all input consumed by the parser,
  or <tt>undefined</tt> if the parse failed. The value generated by the parser
  is stored in the <tt>value</tt> property of the returned <tt>PStream</tt>.
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'StringPS',
  implements: ['foam.parse.PStream'],

  properties: [
    {
      /**
       * The string being parsed. Wrapped in a one-element array as a
       * psuedo-pointer, to avoid copying the string.
       */
      class: 'Unsafe',
      name: 'str'
    },
    {
      /** The current position of the parsing. */
      class: 'Unsafe',
      name: 'pos'
    },
    {
      /** Shorthand accessor for the current character (at <tt>pos</tt>). */
      name: 'head',
      getter: function() {
        return this.str[0][this.pos];
      }
    },
    {
      /**
       * Shorthand accessor that builds and caches a <tt>PStream</tt> for the
       * remainder of the string, after the first character.
       */
      name: 'tail',
      getter: function() {
        if ( ! this.instance_.tail ) {
          var ps = this.cls_.create();
          ps.str = this.str;
          ps.pos = this.pos + 1;
          this.instance_.tail = ps;
        }
        return this.instance_.tail;
      },
      setter: function(nu) {
        this.instance_.tail = nu;
      }
    },
    {
      /** The value of the parse. Defaults to the parsed character. */
      name: 'value',
      setter: function(value) { this.instance_.value = value; },
      getter: function() {
        return this.instance_.value !== undefined ?
          this.instance_.value :
          this.str[0].charAt(this.pos - 1);
      }
    }
  ],

  methods: [
    function initArgs() {
      /**
       * Prevents the usual <tt>create()</tt> flow from populating the
       * arguments. This greatly improves the speed of <tt>PStream</tt> creation
       * during parsing.
       */
    },

    function setValue(value) {
      /**
       * Sets the value parsed at this location. Returns a new <tt>PStream</tt>,
       * since they're immutable.
       * @param {any=} value
       */
      // Force undefined values to null so that hasOwnProperty checks are faster.
      if ( value === undefined ) value = null;
      var ps = this.cls_.create();
      ps.str = this.str;
      ps.pos = this.pos;
      ps.tail = this.tail;
      ps.value = value;
      return ps;
    },

    function setString(s) {
      /**
       * Overriddes the string. Initializes this <tt>PStream</tt> if it's new.
       * @param {String} s
       */
      this.pos = 0;
      this.value = null;
      if ( ! this.str ) this.str = [];
      this.str[0] = s;
    }
  ]
});


/** Helper library for parsers. */
foam.LIB({
  name: 'foam.Parser',
  methods: [
    function coerce(x) {
      /**
       * Converts the input to a parser according to the following rules:
       *
       * <ul><li>Strings are converted to <tt>Literal</tt> parsers.</li></ul>
       *
       * @param {any} x The input to be coerced to a parser.
       * @return {Parser=} The parser, or undefined on failure.
       */
      return typeof x === 'string' ? foam.parse.Literal.create({literal: x}) :
          undefined;
    },
    function isInstance(obj) {
      /**
       * Use {Parser} as your parameter type to accept both a parser or a string.
       * @param {any=} obj
       */
      return foam.parse.Parser.isInstance(obj) || foam.String.isInstance(obj);
    }

  ]
});

/**
 * Property type for an array of parsers. Used by <tt>Alt</tt>, <tt>Seq</tt>,
 * and other compound parsers.
 *
 * Upgrades simple strings to <tt>Literal</tt> parsers.
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'ParserArray',
  extends: 'FObjectArray',

  properties: [
    ['of', 'foam.parse.Parser'],
    ['adapt', function(_, a) {
        if ( ! a ) return [];
        var b = new Array(a.length);
        for ( var i = 0; i < a.length; i++ ) {
          b[i] = foam.parse.Parser.isInstance(a[i]) ? a[i] :
              foam.Parser.coerce(a[i]);
        }
        return b;
      }
    ]
  ]
});

/**
 * Property type for a single child parser.
 *
 * Upgrades simple strings to a <tt>Literal</tt> parser.
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'ParserProperty',
  extends: 'Property',

  properties: [
    {
      name: 'adapt',
      value: function(_, v) {
        return foam.parse.Parser.isInstance(v) ? v : foam.Parser.coerce(v);
      }
    }
  ]
});


/** Interface for parsers that wrap a single inner parser. */
foam.INTERFACE({
  package: 'foam.parse',
  name: 'ParserDecorator',

  properties: [
    {
      class: 'foam.parse.ParserProperty',
      name: 'parser',
      final: true
    }
  ]
});


/**
 * Parses a literal string, case-sensitive.
 *
 * Value defaults to the parsed string.
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'Literal',
  implements: ['foam.parse.Parser'],

  properties: [
    {
      /** The string to parse literally. */
      name: 'literal',
      final: true
    },
    {
      /** The returned value. */
      name: 'value',
      final: true
    }
  ],

  methods: [
    function parse(ps) {
      /**
       * Attempts to parse this literal out of <tt>ps</tt>.
       * @param {foam.parse.PStream} ps
       */
      var str = this.literal;
      for ( var i = 0; i < str.length; i++, ps = ps.tail ) {
        if ( str.charAt(i) !== ps.head ) {
          return undefined;
        }
      }
      return ps.setValue(this.value !== undefined ? this.value : str);
    }
  ]
});

/**
 * Parses a literal string, ignoring case.
 *
 * Value defaults to the literal string, using the canonical capitalization.
 * (Eg. A parser for 'abc' that gets input 'ABc' will set value to 'abc'.)
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'LiteralIC',
  implements: ['foam.parse.Parser'],

  properties: [
    {
      /** The string we want to parse literally. */
      name: 'literal',
      final: true,
      postSet: function(old, nu) {
        this.lower = nu.toLowerCase();
      }
    },
    {
      /** Target string converted to lower case. */
      name: 'lower',
      final: true
    },
    {
      /** The returned value. */
      name: 'value',
      final: true
    }
  ],

  methods: [
    function parse(ps) {
      /**
       * Attempts to parse this literal out of <tt>ps</tt>, ignoring case.
       * @param {foam.parse.PStream} ps
       */
      var str = this.lower;
      for ( var i = 0; i < str.length; i++, ps = ps.tail ) {
        if ( ! ps.head || str.charAt(i) !== ps.head.toLowerCase() ) {
          return undefined;
        }
      }
      return ps.setValue(this.value !== undefined ? this.value : this.literal);
    }
  ]
});

/**
 * Attempts to parse each of several parsers in turn. The first one that parses
 * successfully becomes the returned value.
 *
 * If all the inner parsers fail, or there are none, <tt>Alternate</tt> fails to
 * parse.
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'Alternate',
  implements: ['foam.parse.Parser'],

  properties: [
    {
      /**
       * The array of child parsers. Each is tested in order. If a child parser
       * succeeds, it becomes the value for the <tt>Alternate</tt>. If a child
       * parser fails, this backtracks to the original input location and tries
       * the next one.
       */
      class: 'foam.parse.ParserArray',
      name: 'args',
      final: true
    }
  ],

  methods: [
    function parse(ps, obj) {
      /**
       * Tries each child parser in turn. If one succeeds, we return that
       * value. If all fail (or there are none) this fails too.
       * @param {foam.parse.PStream} ps
       * @param {any=} obj
       */
      var args = this.args;
      for ( var i = 0, p; p = args[i]; i++ ) {
        var ret = p.parse(ps, obj);
        if ( ret ) return ret;
      }
      return undefined;
    }
  ]
});

/**
 * Runs an array of parsers in order, one after the other.
 *
 * If each parser succeeds, returns an array of their values.
 *
 * If any child parser fails, so does <tt>Sequence</tt>.
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'Sequence',
  implements: ['foam.parse.Parser'],

  properties: [
    {
      /** The inner parsers to run sequentially. */
      class: 'foam.parse.ParserArray',
      name: 'args',
      final: true
    }
  ],

  methods: [
    function parse(ps, obj) {
      /**
       * Parses each child parser in order, collecting their results.
       * @param {foam.parse.PStream} ps
       * @param {any=} obj
       */
      var ret = [];
      var args = this.args;
      for ( var i = 0, p; p = args[i]; i++ ) {
        if ( ! ( ps = p.parse(ps, obj) ) ) return undefined;
        ret.push(ps.value);
      }
      return ps.setValue(ret);
    }
  ]
});

/**
 * Combinator that expects the inner parser to return an array of strings.
 *
 * Returns those strings concatenated into a single string.
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'String',
  implements: ['foam.parse.Parser', 'foam.parse.ParserDecorator'],
  methods: [
    function parse(ps, obj) {
      /**
       * Runs the inner parser, and concatenates its results.
       * @param {foam.parse.PStream} ps
       * @param {any=} obj
       */
      ps = this.parser.parse(ps, obj);
      return ps ? ps.setValue(ps.value.join('')) : undefined;
    }
  ]
});

/**
 * Variant of <tt>Sequence</tt> that returns the result of only one of its child
 * parsers, rather than an array.
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'SequenceAt',
  implements: ['foam.parse.Parser'],

  properties: [
    {
      /**
       * Array of child parsers, to be run sequentially.
       *
       * Only the result of the <tt>index</tt>th parser is returned.
       */
      class: 'foam.parse.ParserArray',
      name: 'args',
      final: true
    },
    {
      /** The index of the child parser whose value should be returned. */
      name: 'index',
      final: true
    }
  ],

  methods: [
    function parse(ps, obj) {
      /**
       * Runs all the child parsers in order, and returns the <tt>index</tt>th
       * result.
       * @param {foam.parse.PStream} ps
       * @param {any=} obj
       */
      var ret;
      var args = this.args;
      var n = this.index;
      for ( var i = 0, p; p = args[i]; i++ ) {
        if ( ! ( ps = p.parse(ps, obj) ) ) return undefined;
        if ( i === n ) ret = ps.value;
      }
      return ps.setValue(ret);
    }
  ]
});

/**
 * Combinator that tries to run a single inner parser.
 *
 * If the inner parser succeeds, returns its value.
 *
 * If the inner parser fails, returns null.
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'Optional',
  implements: ['foam.parse.Parser', 'foam.parse.ParserDecorator'],

  methods: [
    function parse(ps, obj) {
      /**
       * Run the inner parser. If it fails, return null instead.
       * @param {foam.parse.PStream} ps
       * @param {any=} obj
       */
      var res = this.parser.parse(ps, obj);
      return res || ps.setValue(null);
    }
  ]
});

/**
 * Parses any single character, returning it as the value.
 *
 * A singleton, since it has no state.
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'AnyChar',
  implements: ['foam.parse.Parser'],

  axioms: [foam.pattern.Singleton.create()],

  methods: [
    function parse(ps) {
      /**
       * Parse any character and return it. Fails at EOF.
       * @param {foam.parse.PStream} ps
       */
      return ps.head ? ps.tail : undefined;
    }
  ]
});

/**
 * Parses a single character that is not contained in the given <tt>string</tt>.
 *
 * Returns the character parsed.
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'NotChars',
  implements: ['foam.parse.Parser'],

  properties: [
    {
      /** The string of banned characters. */
      name: 'string',
      final: true
    }
  ],

  methods: [
    function parse(ps) {
      /**
       * Parses any character not in the banned string.
       * @param {foam.parse.PStream} ps
       */
      return ps.head && this.string.indexOf(ps.head) === -1 ?
        ps.tail : undefined;
    }
  ]
});

/**
 * Takes two characters, and parses any character in that range (inclusive).
 *
 * Eg. given 'a' and 'z', parses any lowercase letter.
 *
 * Returns the parsed character. Fails on EOF.
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'Range',
  implements: ['foam.parse.Parser'],

  properties: [
    {
      /** The lower end of the range. */
      name: 'from',
      final: true
    },
    {
      /** The higher end of the range. */
      name: 'to',
      final: true
    }
  ],

  methods: [
    function parse(ps) {
      /**
       * Parses a single character that's inside the range.
       *
       * Fails on EOF, or an out-of-range character.
       * @param {foam.parse.PStream} ps
       */
      if ( ! ps.head ) return undefined;
      return ( this.from <= ps.head && ps.head <= this.to ) ?
          ps.tail.setValue(ps.head) :
          undefined;
    }
  ]
});

/**
 * Runs a child parser repeatedly, capturing 0 or more instances.
 *
 * Optionally can have a second child parser for parsing a delimiter.
 *
 * If the delimiter parser is given, parses: body, delimiter, body, deliminter,
 * body, ...
 *
 * Returns an array of all the results of the body parser. Discards the results
 * of the delimiter parser, if any.
 *
 * One final option: a minimum can be provided. The parser will fail if it can't
 * parse at least that many bodies.
 *
 * When minimum is 0 (the default) parsing nothing is legal and returns the
 * empty array.
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'Repeat',
  implements: ['foam.parse.Parser', 'foam.parse.ParserDecorator'],

  properties: [
    {
      /** Optional parser for the delimiter between bodies. */
      class: 'foam.parse.ParserProperty',
      name: 'delimiter'
    },
    {
      /** Optional minimum number of bodies. Defaults to 0. */
      class: 'Int',
      name: 'minimum'
    }
  ],

  methods: [
    function parse(ps, obj) {
      /**
       * Parses <tt>minimum</tt> or more bodies, separated by
       * <tt>delimiter</tt> if provided.
       * @param {foam.parse.PStream} ps
       * @param {any=} obj
       */
      var ret = [];
      var p = this.parser;
      var last;
      while ( ps ) {
        last = ps;
        ps = p.parse(ps, obj);
        if ( ps ) ret.push(ps.value);
        if ( this.delimiter && ps ) {
          last = ps;
          ps = this.delimiter.parse(ps, obj);
        }
      }

      if ( this.minimum > 0 && ret.length < this.minimum ) return undefined;
      return last.setValue(ret);
    }
  ]
});

/** Shorthand for <tt>Repeat</tt> with a minimum of 1. */
foam.CLASS({
  package: 'foam.parse',
  name: 'Plus',
  extends: 'foam.parse.Repeat',

  properties: [
    ['minimum', 1]
  ]
});

/** Variant of <tt>Repeat</tt> that discards the result. Returns null. */
foam.CLASS({
  package: 'foam.parse',
  name: 'RepeatDrop',
  extends: 'foam.parse.Repeat',

  methods: [
    function parse(ps, obj) {
      /**
       * Parses <tt>minimum</tt> or more bodies, separated by
       * <tt>delimiter</tt> if provided. The result is discarded and null is
       * returned.
       * @param {foam.parse.PStream} ps
       * @param {any=} obj
       */
      var res;
      var count = 0;
      var p = this.parser;
      if ( ! this.delimiter ) {
        // Fast path for the case without a delimiter.
        while ( res = p.parse(ps, obj) ) {
          ps = res;
          count++;
        }
        return this.minimum > 0 && count < this.minimum ? undefined :
            ps.setValue(null);
      }

      // Full version that handles delimiters.
      var p = this.parser;
      var res;
      while ( ps ) {
        res = ps;
        ps = p.parse(ps, obj);
        if ( ps ) count++;
        if ( this.delimiter && ps ) {
          res = ps;
          ps = this.delimiter.parse(ps, obj);
        }
      }

      if ( this.minimum > 0 && count < this.minimum ) return undefined;
      return res.setValue(null);
    }
  ]
});

/**
 * Parser that finds 0 or more instances of one parser, until it finds a
 * terminator.
 *
 * This is "non-greedy" in the regular expression sense: it tries to parse the
 * terminator, and as soon as it succeeds <tt>RepeatUntil</tt> is done.
 *
 * Only when parsing the terminator fails does it try to parse <tt>parser</tt>.
 *
 * Output value is an array of <tt>parser</tt> results, possibly empty.
 *
 * If both <tt>terminator</tt> and <tt>parser</tt> fail to parse at the same
 * point, <tt>RepeatUntil</tt> fails.
 *
 * Some common example uses:
 * <pre>
 * string: seqAt(1, literal('"'), repeatUntil(anyChar(), literal('"')))
 * lineComment: seq(literal('//', repeatUntil(anyChar(), literal('\n')))
 * </pre>
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'RepeatUntil',
  implements: ['foam.parse.Parser', 'foam.parse.ParserDecorator'],

  properties: [
    {
      class: 'foam.parse.ParserProperty',
      name: 'terminator',
      required: true
    }
  ],

  methods: [
    function parse(ps, obj) {
      /**
       * @param {foam.parse.PStream} ps
       * @param {any=} obj
       */
      var ret = [];
      while ( ps ) {
        var tps = this.terminator.parse(ps, obj);
        if ( tps ) return tps.setValue(ret);
        ps = this.parser.parse(ps, obj);
        if ( ps ) ret.push(ps.value);
      }
      // If we come down here, then both the terminator and body parser failed.
      // That means RepeatUntil fails.
      return undefined;
    }
  ]
});

/**
 * Wrapper that adds an action to a parser. If the inner parser succeeds, its
 * return value is passed to the provided action, and its output is returned.
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'ParserWithAction',
  implements: ['foam.parse.Parser', 'foam.parse.ParserDecorator'],

  properties: [
    {
      /**
       * A function which accepts the inner parser's value, and returns the
       * value to be returned from this parser.
       */
      name: 'action'
    }
  ],

  methods: [
    function parse(ps, obj) {
      /**
       * @param {foam.parse.PStream} ps
       * @param {any=} obj
       */
      ps = this.parser.parse(ps, obj);
      return ps ?
        ps.setValue(this.action(ps.value)) :
        undefined;
    }
  ]
});

/** Runs another parser in the grammar by name. */
foam.CLASS({
  package: 'foam.parse',
  name: 'Symbol',
  implements: ['foam.parse.Parser'],

  properties: [
    {
      /** The name of another parser in the grammar. */
      name: 'name',
      final: true
    }
  ],

  methods: [
    function parse(ps, grammar) {
      /**
       * @param {foam.parse.PStream} ps
       * @param {foam.parse.Grammar} grammar
       */
      var p = grammar.getSymbol(this.name);
      if ( ! p ) {
        console.error('No symbol found for', this.name);
        return undefined;
      }
      return p.parse(ps, grammar);
    }
  ]
});


/**
 * A Singleton with helper methods to create instances of all the other parsers.
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'Parsers',

  axioms: [foam.pattern.Singleton.create()],

  methods: [
    function seq(parsers) {
      /**
       * Combinator that accepts a list of parsers, and runs each of them in
       * order.
       *
       * If any of them fails, <tt>seq()</tt> fails.
       *
       * If they all succeed, <tt>seq()</tt> succeeds, and its value is an array
       * of the values from the inner parsers.
       *
       * @param {...Parser} parsers The sequence of parsers to run.
       * @return {foam.parse.Parser} The combined parser.
       */
      return foam.lookup('foam.parse.Sequence').create({
        args: Array.from(arguments)
      });
    },

    function repeatDrop(p, delim, min) {
      /**
       * Variant of <tt>repeat()</tt> that discards the result.
       *
       * Useful for consuming whitespace or other discarded input.
       *
       * @param {Parser} p The body parser.
       * @param {Parser=} delim Optional delimiter parser.
       * @param {Number=} min Optional minimum number of items to parse.
       *    Defaults to 0.
       * @return {foam.parse.Parser} The combined parser.
       */
      return foam.lookup('foam.parse.RepeatDrop').create({
        parser: p,
        delimiter: delim,
        minimum: min
      });
    },

    function repeatUntil(parser, terminator) {
      /**
       * Parser that finds 0 or more instances of one parser, until it finds a
       * terminator.
       *
       * This is "non-greedy" in the regular expression sense: it parses the
       * terminator first, and returns if that succeeds.
       *
       * Only when parsing the terminator fails does it try to parse
       * <tt>parser</tt>.
       *
       * Output value is an array of <tt>parser</tt> results, possibly empty.
       *
       * If both <tt>terminator</tt> and <tt>parser</tt> fail to parse at the
       * same point, <tt>RepeatUntil</tt> fails.
       *
       * Some common example uses:
       * <pre>
       * string: seqAt(1, literal('"'), repeatUntil(anyChar(), literal('"')))
       * lineComment: seq(literal('//', repeatUntil(anyChar(), literal('\n')))
       * </pre>
       *
       * @param {Parser} parser The body parser.
       * @param {Parser} terminator The terminating parser.
       * @return {foam.parse.Parser} The combined parser.
       */
      return foam.lookup('foam.parse.RepeatUntil').create({
        parser: parser,
        terminator: terminator
      });
    },

    function alt(parsers) {
      /**
       * Combinator for choosing between several parsers.
       *
       * Accepts a list of parsers, and tries each in turn.
       *
       * If a parser fails, <tt>alt()</tt> tries the next one. The first one to
       * succeed becomes the result of the <tt>alt()</tt>.
       *
       * If none of the parsers succeeds, or the list of parsers is empty,
       * <tt>alt()</tt> fails.
       *
       * @param {...Parser} parsers The sequence of parsers to try.
       * @return {foam.parse.Parser} The combined parser.
       */
      return foam.lookup('foam.parse.Alternate').create({
        args: Array.from(arguments)
      });
    },

    function sym(name) {
      /**
       * Looks up another parser in the grammar by name, and runs it here.
       *
       * The result of this parser is the same as the named parser.
       *
       * @param {String} name The other parser to call.
       * @return {foam.parse.Parser} The parser named.
       */
      return foam.lookup('foam.parse.Symbol').create({
        name: name
      });
    },

    function seqAt(n, parsers) {
      /**
       * Variant of <tt>seq()</tt> that returns the value from one of its inner
       * parsers, rather than an array of their results.
       *
       * @param {Number} n The index of the parser whose value to return.
       * @param {...Parser} parsers The sequence of parsers to run.
       * @return {foam.parse.Parser} The combined parser.
       */
      return foam.lookup('foam.parse.SequenceAt').create({
        index: n,
        args: Array.from(arguments).slice(1)
      });
    },

    function repeat(p, delim, min) {
      /**
       * Combinator that runs a parser 0 or more times and returns an array of
       * results.
       *
       * There are two different ways to use <tt>repeat()</tt>:
       *
       * <ul>
       *
       * <li>Given just a single parser <tt>p</tt>, <tt>repeat()</tt> will run
       * that parser repeatedly, until it fails, and return an array of the
       * results.
       *
       * <li>Given two parsers, <tt>p</tt> and <tt>delim</tt>, <tt>repeat()</tt>
       * will run them alternately. <tt>delim</tt>'s results are discarded, so
       * the output array contains only <tt>p</tt>'s results. As soon as either
       * parser fails, <tt>repeat()</tt> returns the array of results so
       * far.</li>
       *
       * </ul>
       *
       * In either of the above modes, an optional minimum count can be
       * supplied as well. <tt>repeat()</tt> will fail without consuming any
       * input, if it can't parse <tt>p</tt> at least <tt>min</tt> times.
       *
       * The minimum defaults to 0. <strong>NB:</strong> That means that if
       * <tt>p</tt> fails on the first try, and <tt>min</tt> is set to 0 or not
       * provided, then <tt>repeat()</tt> will <strong>succeed</strong> with an
       * empty array as its value.
       *
       * @param {Parser} p The parser for the body of the repeat.
       * @param {Parser=} delim Optional delimiter parser.
       * @param {Number=} min Optional minimum number of values to parse.
       *     Defaults to 0.
       * @return {foam.parse.Parser} The combined parser.
       */
      return foam.lookup('foam.parse.Repeat').create({
        parser: p,
        minimum: min,
        delimiter: delim
      });
    },

    function plus(p, delim) {
      /**
       * Shorthand for <tt>repeat(p, delim, 1)</tt> to parse 1 or more, rather
       * than 0 or more.
       *
       * @param {Parser} p Body parser.
       * @param {Parser=} delim Optional delimiter parser.
       * @return {foam.parse.Parser} The combined parser.
       */
      return foam.lookup('foam.parse.Plus').create({
        parser: p,
        delimiter: delim
      });
    },

    function str(p) {
      /**
       * Combinator that wraps a single parser whose value is an array of
       * strings. <tt>str(p)</tt> joins <tt>p</tt>'s results into a single
       * string.
       *
       * @param {Parser} p The inner parser to wrap.
       * @return {foam.parse.Parser} The decorated parser.
       */
      return foam.lookup('foam.parse.String').create({
        parser: p
      });
    },

    function range(start, end) {
      /**
       * Parser for any single character within an inclusive range.
       *
       * Accepts two characters, and will parse any single character whose
       * Unicode value lies inside the range.
       *
       * Eg. <tt>range('A', 'Z')</tt> will parse one uppercase letter.
       *
       * @param {String} start The starting character of the range.
       * @param {String} end The ending character of the range.
       * @return {foam.parse.Parser} The parser.
       */
      return foam.lookup('foam.parse.Range').create({
        from: start,
        to: end
      });
    },

    function notChars(s) {
      /**
       * Parser that accepts any single character which is not found in a given
       * string.
       *
       * This parser's value is a one-character string.
       *
       * @param {String} s The string of banned characters.
       * @return {foam.parse.Parser} Parser for a single character not in s.
       */
      return foam.lookup('foam.parse.NotChars').create({
        string: s
      });
    },

    function optional(p) {
      /**
       * Combinator that attempts to run its inner parser <tt>p</tt>.
       *
       * If <tt>p</tt> succeeds, <tt>optional(p)</tt> succeeds with its value.
       *
       * If <tt>p</tt> fails, <tt>optional(p)</tt> succeeds with value
       * <tt>null</tt>.
       *
       * @param {Parser} p The inner parser to try optionally.
       * @return {foam.parse.Parser} The combined parser.
       */
      return foam.lookup('foam.parse.Optional').create({
        parser: p
      });
    },

    function literal(s, value) {
      /**
       * Parser for an exact, literal string.
       *
       * Parses exactly that string, or fails.
       *
       * The parser returns <tt>value</tt> if provided, or the string by
       * default.
       *
       * <tt>literal</tt> is case-sensitive. Use <tt>literalIC</tt> instead to
       * ignore case.
       *
       * @param {String} s The string to parse.
       * @param {any=} value A successful parse returns this value, if provided.
       *     Otherwise the parsed string is returned.
       * @return {foam.parse.Parser} The parser for the given literal.
       */
      return foam.lookup('foam.parse.Literal').create({
        literal: s,
        value: value
      });
    },

    function literalIC(s, value) {
      /**
       * Variant of <tt>literal()</tt> the ignores case. See <tt>literal</tt>
       * for details.
       *
       * When <tt>value</tt> is not provided, the string is returned with the
       * canonical capitalization passed to <tt>literalIC</tt>, not the input
       * capitalization.
       *
       * @param {String} s The string to parse, ignoring case.
       * @param {any=} value Returns this on a successful parse, if provided.
       *     Otherwise the parsed string (not <tt>s</tt>) is returned.
       * @return {foam.parse.Parser} The constructed parser.
       */
      return foam.lookup('foam.parse.LiteralIC').create({
        literal: s,
        value: value
      });
    },

    function anyChar() {
      /**
       * Parser for any single character. Returns the parsed character.
       * @return {foam.parse.Parser} The anyChar parser.
       */
      return foam.parse.AnyChar.create();
    }
  ]
});

/**
 * A pair of name and parser. A collection of these with optional actions is a
 * Grammar.
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'PSymbol',

  properties: [
    {
      /** Name for this parser. */
      class: 'String',
      name: 'name'
    },
    {
      /** The parser itself. */
      of: 'foam.parse.Parser',
      name: 'parser'
    }
  ]
});

/**
 * A Grammar is a set of named parsers (<tt>symbols</tt>) and (possibly empty)
 * set of actions for those parsers.
 *
 * The usual flow is:
 * <pre>
 * var g = foam.parse.Grammar.create({
 *   symbols: function(anyChar, literal, repeat) {
 *     return {
 *       START: ...,
 *       mySym: ...,
 *       etc: ...
 *     };
 *   }
 * });
 *
 * g.addActions({
 *   START: function() { ... },
 *   etc: function() { ... }
 * });
 *
 * g.parseString('some string to parse');
 * </pre>
 */
foam.CLASS({
  package: 'foam.parse',
  name: 'Grammar',

  requires: [
    'foam.parse.StringPS',
    'foam.parse.Parsers'
  ],

  properties: [
    {
      /**
       * Array of named symbols (<tt>PSymbol</tt>). Usually you won't pass it in
       * like that, though.
       *
       * If <tt>symbols</tt> is set to a function, it is called using
       * <tt>foam.Function.withArgs</tt>, passing in all the parser constructors
       * defined in <tt>foam.parse.Parsers</tt>.
       *
       * That means a function like
       * <tt>function(literal, optional, repeat) {</tt> will be passed those
       * constructors as arguments, so they're in scope.
       *
       * The function should return an object whose keys are the names and
       * values are the parsers.
       *
       * <tt>symbols</tt> can also be passed as just an object mapping names to
       * parsers.
       */
      class: 'FObjectArray',
      of: 'foam.parse.PSymbol',
      name: 'symbols',
      adapt: function(_, o) {
        if ( Array.isArray(o) ) return o;

        if ( typeof o === 'function' ) {
          var args = o.toString().match(/\((.*?)\)/);
          if ( ! args ) {
            throw 'Could not parse arguments from parser factory function';
          }

          o = foam.Function.withArgs(o, this.Parsers.create(), this);
        }

        var a = [];
        for ( var key in o ) {
          a.push(foam.parse.PSymbol.create({
            name: key,
            parser: o[key]
          }));
        }
        return a;
      }
    },
    {
      /** Internal symbol lookup table, using the names in <tt>symbols</tt>. */
      name: 'symbolMap_',
      expression: function(symbols) {
        var m = {};
        for ( var i = 0; i < symbols.length; i++ ) {
          if ( m[symbols[i].name] ) {
            console.error('Duplicate symbol found', symbols[i].name);
          }
          m[symbols[i].name] = symbols[i];
        }
        return m;
      }
    },
    {
      /** Internal <tt>PStream</tt> representing the input stream. */
      name: 'ps',
      factory: function() {
        return this.StringPS.create();
      }
    }
  ],

  methods: [
    function parseString(str, opt_name) {
      /**
       * Attempts to parse <tt>str</tt> and return the parsed value.
       *
       * The starting symbol is <tt>opt_name</tt>, or defaults to
       * <tt>START</tt>.
       *
       * <tt>parseString</tt> returns the value of that starting parser,
       * whatever that may be, or undefined if parsing fails.
       *
       * @param {String} str The input string to parse.
       * @param {String=} opt_name Optional starting symbol. Defaults to
       *     <tt>START</tt>.
       * @return {any=} The value of the parser, or undefined if parsing fails.
       */
      opt_name = opt_name || 'START';

      this.ps.setString(str);
      var start = this.getSymbol(opt_name);
      foam.assert(start, 'No symbol found for', opt_name);

      var result = start.parse(this.ps, this);
      return result && result.value;
    },

    function getSymbol(name) {
      /**
       * Helper function that returns a parser, given its name.
       * @param {String} name The name of the parser.
       * @return {Parser=} The matching parser, or undefined if not
       *     found.
       */
      var sym = this.symbolMap_[name];
      return sym && sym.parser;
    },

    function addActions(map) {
      /**
       * Given a map of symbol names to actions (see <tt>addAction</tt> for
       * details), adds each action to this grammar.
       *
       * @param {Object} map Map of symbols names to actions.
       * @return {foam.parse.Grammar} Returns this grammar, for chaining.
       */
      for ( var key in map ) {
        this.addAction(key, map[key]);
      }
      return this;
    },

    function addAction(name, action) {
      /**
       * Adds an action to this grammar.
       *
       * An action is a function that transforms the value of a parser. It's
       * useful for converting the raw output of a parser into some more
       * structured result.
       *
       * An action receives one argument (the parser's result) and whatever it
       * returns becomes the new value for the parser. Note that this is
       * recursive, and that leaf actions are run first.
       *
       * For example, suppose my symbols are:
       * <pre>
       * {
       *   START: seq(sym('number'), literal('+'), sym('number')),
       *   number: repeat(sym('digit'), undefined, 1),
       *   digit: range('0', '9')
       * }
       * </pre>
       *
       * then I could define the following actions to evaluate the addition in
       * place:
       *
       * <pre>
       * g.addAction('number', function(chars) {
       *   return Number.parseInt(chars.join(''));
       * });
       * g.addAction('START', function(args) {
       *   return args[0] + args[2];
       * });
       * </pre>
       *
       * This makes the most sense working from the bottom up:
       *
       * <ul>
       * <li><tt>digit</tt> returns a single-character string (and has no
       * action).</li>
       * <li><tt>number</tt> parses an array of those single-character strings.
       * Its action joins those into one string, then parses it to a
       * number.</li>
       * <li><tt>START</tt> parses three things, which <tt>seq</tt> returns as
       * an array. <tt>START</tt>'s action receives this array, and adds the 0th
       * and 2nd elements, which are the numbers produced by the two
       * <tt>number</tt> parsers.
       *
       * @param {String} name The symbol to attach this action to.
       * @param {Function} action The action function. The function should
       *     take one argument (the parser's value) and return the new value.
       * @return {foam.parse.Grammar} Returns this grammar, for easy chaining.
       */
      for ( var i = 0; i < this.symbols.length; i++ ) {
        if ( this.symbols[i].name === name ) {
          this.symbols[i].parser = foam.parse.ParserWithAction.create({
            parser: this.symbols[i].parser,
            action: action
          });
        }
      }

      // TODO(adamvy): Array property should help me here
      this.pub('propertyChange', 'symbols', this.slot('symbols'));
      return this;
    }
  ]
});
